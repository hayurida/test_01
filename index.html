<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ìŠ¤ë„¤ì´í¬ ê²Œì„ (Single HTML)</title>
  <style>
    :root {
      --bg: #0a101a;
      --panel: #0d2234;
      --accent: #2ed573;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100svh;
      display: grid;
      place-items: center;
      color: #eaf2ff;
      background:
        radial-gradient(1200px 600px at 50% -10%, #183a5a22, transparent 60%),
        var(--bg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial, sans-serif;
    }
    main.wrap {
      width: min(92vw, 640px);
      padding: 20px 20px 28px;
      border-radius: 16px;
      background: linear-gradient(180deg, #0f283e, var(--panel));
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }
    h1 {
      margin: 0 0 12px;
      font-size: clamp(18px, 3.6vw, 24px);
      letter-spacing: .2px;
    }
    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 10px;
    }
    #score {
      font-weight: 800;
      color: var(--accent);
    }
    .controls { display: flex; gap: 8px; }
    .controls button {
      background: #193a4d;
      color: #eaf2ff;
      border: 0;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      transition: transform .06s ease, background .2s ease;
    }
    .controls button:hover { background: #20566e; }
    .controls button:active { transform: translateY(1px); }

    #board {
      width: 100%;
      height: auto;
      image-rendering: pixelated; /* í”½ì…€ ëŠë‚Œ ì‚´ë¦¬ê¸° */
      border-radius: 12px;
      outline: 2px solid #1d3557;
      background: #021222;
      display: block;
    }

    .help {
      opacity: .8;
      font-size: .9rem;
      margin: 10px 0 0;
    }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>ìŠ¤ë„¤ì´í¬ ê²Œì„</h1>

    <div class="hud">
      <div>ì ìˆ˜: <span id="score">0</span></div>
      <div class="controls">
        <button id="btnRestart" aria-label="ì¬ì‹œì‘ (R)">ğŸ”„ ì¬ì‹œì‘</button>
        <button id="btnPause" aria-label="ì¼ì‹œì •ì§€/ì¬ê°œ (P)">â¯ ì¼ì‹œì •ì§€</button>
      </div>
    </div>

    <canvas id="board" width="504" height="504" role="img" aria-label="ìŠ¤ë„¤ì´í¬ ê²Œì„ ë³´ë“œ"></canvas>
    <p class="help">ì´ë™: â† â†‘ â†’ â†“  |  ì¼ì‹œì •ì§€/ì¬ê°œ: P  |  ì¬ì‹œì‘: R</p>
  </main>

  <script>
    (() => {
      // ====== ì„¤ì •ê°’ ======
      const tileCount = 21;      // ê²©ì ìˆ˜ (ì •ì‚¬ê°í˜•)
      const tileSize  = 24;      // íƒ€ì¼(ì…€) í•œ ë³€ì˜ í”½ì…€
      const size = tileCount * tileSize; // ìº”ë²„ìŠ¤ í•œ ë³€ ê¸¸ì´

      // ====== ìº”ë²„ìŠ¤/DOM ======
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');
      canvas.width = size; canvas.height = size;

      const scoreEl = document.getElementById('score');
      const btnRestart = document.getElementById('btnRestart');
      const btnPause = document.getElementById('btnPause');

      // ====== ê²Œì„ ìƒíƒœ ======
      let snake, direction, nextDirection, food, score, isPaused, isOver, speed, lastTick;

      function init() {
        // ë±€ ì´ˆê¸° ìœ„ì¹˜: í™”ë©´ ì¤‘ì•™
        snake = [{ x: Math.floor(tileCount/2), y: Math.floor(tileCount/2) }];
        direction = { x: 1, y: 0 };         // ì²˜ìŒì—” ì˜¤ë¥¸ìª½ ì´ë™
        nextDirection = { ...direction };   // ë‹¤ìŒ ì´ë™ ë°©í–¥(í‚¤ ì…ë ¥ ë²„í¼)
        food = spawnFood();                 // ìŒì‹ ìƒì„±
        score = 0;
        speed = 7;                          // 1ì´ˆë‹¹ ì´ë™ íšŸìˆ˜(ë‚œì´ë„)
        lastTick = 0;
        isPaused = false;
        isOver = false;
        scoreEl.textContent = score;
        btnPause.textContent = 'â¯ ì¼ì‹œì •ì§€';
      }

      // ë¹ˆ ì¹¸ì— ìŒì‹ ìƒì„±
      function spawnFood() {
        while (true) {
          const p = {
            x: Math.floor(Math.random() * tileCount),
            y: Math.floor(Math.random() * tileCount)
          };
          if (!snake || !snake.some(s => s.x === p.x && s.y === p.y)) return p;
        }
      }

      // í•œ í‹± ì—…ë°ì´íŠ¸
      function update() {
        // ì§ì „ í‹±ì—ì„œ í™•ì •ëœ ë°©í–¥ì„ ì‹¤ì œ ì´ë™ ë°©í–¥ìœ¼ë¡œ ë°˜ì˜
        direction = nextDirection;

        const head = snake[0];
        const newHead = { x: head.x + direction.x, y: head.y + direction.y };

        // ë²½ ì¶©ëŒ(í™”ë©´ ë°–ì´ë©´ ê²Œì„ ì˜¤ë²„)
        if (newHead.x < 0 || newHead.y < 0 || newHead.x >= tileCount || newHead.y >= tileCount) {
          return gameOver();
        }
        // ìê¸° ëª¸ê³¼ ì¶©ëŒ
        if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
          return gameOver();
        }

        // ë¨¸ë¦¬ ì¶”ê°€
        snake.unshift(newHead);

        // ìŒì‹ ì„­ì·¨ ì—¬ë¶€
        if (newHead.x === food.x && newHead.y === food.y) {
          score++;
          scoreEl.textContent = score;
          // ì ìˆ˜ì— ë¹„ë¡€í•´ ì†ë„ ì†Œí­ ì¦ê°€(ìƒí•œ 18)
          speed = Math.min(18, 7 + Math.floor(score / 4));
          food = spawnFood();
          // ê¼¬ë¦¬ ìœ ì§€(ê¸¸ì´ 1 ì¦ê°€)
        } else {
          // ì´ë™ë§Œ: ê¼¬ë¦¬ í•˜ë‚˜ ì œê±°
          snake.pop();
        }
      }

      // ê·¸ë¦¬ê¸°
      function draw() {
        // ë°°ê²½
        ctx.fillStyle = '#0b1724';
        ctx.fillRect(0, 0, size, size);

        // ë³´ì¡° ê·¸ë¦¬ë“œ
        ctx.strokeStyle = 'rgba(255,255,255,.06)';
        ctx.lineWidth = 1;
        for (let i = 1; i < tileCount; i++) {
          const p = i * tileSize;
          ctx.beginPath(); ctx.moveTo(p, 0); ctx.lineTo(p, size); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0, p); ctx.lineTo(size, p); ctx.stroke();
        }

        // ìŒì‹(ë¼ìš´ë“œ ì‚¬ê°í˜•)
        const fx = food.x * tileSize;
        const fy = food.y * tileSize;
        const pad = 4;
        ctx.fillStyle = '#ff4757';
        ctx.beginPath();
        ctx.roundRect(fx + pad, fy + pad, tileSize - 2*pad, tileSize - 2*pad, 6);
        ctx.fill();

        // ë±€
        for (let i = snake.length - 1; i >= 0; i--) {
          const s = snake[i];
          const x = s.x * tileSize, y = s.y * tileSize;

          ctx.fillStyle = i === 0 ? '#2ed573' : '#7bed9f'; // ë¨¸ë¦¬/ëª¸í†µ ìƒ‰ êµ¬ë¶„
          ctx.fillRect(x + 1, y + 1, tileSize - 2, tileSize - 2);

          // ë¨¸ë¦¬ ëˆˆ í‘œí˜„
          if (i === 0) {
            ctx.fillStyle = '#0b1724';
            const ex = x + (direction.x === -1 ? tileSize*0.25 : direction.x === 1 ? tileSize*0.65 : tileSize*0.35);
            const ey = y + (direction.y === -1 ? tileSize*0.25 : direction.y === 1 ? tileSize*0.65 : tileSize*0.35);
            ctx.beginPath(); ctx.arc(ex, ey, 2.5, 0, Math.PI*2); ctx.fill();
          }
        }

        // ì˜¤ë²„/ì¼ì‹œì •ì§€ ì˜¤ë²„ë ˆì´
        if (isOver || isPaused) {
          ctx.fillStyle = 'rgba(0,0,0,.45)';
          ctx.fillRect(0, 0, size, size);
          ctx.fillStyle = '#fff';
          ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const text = isOver ? 'GAME OVER â€” R: ì¬ì‹œì‘' : 'ì¼ì‹œì •ì§€ â€” P: ì¬ê°œ';
          ctx.fillText(text, size/2, size/2);
        }
      }

      // ë©”ì¸ ë£¨í”„ (requestAnimationFrame + í‹± ì§€ì—°)
      function gameLoop(t) {
        if (!lastTick) lastTick = t;
        const step = 1000 / speed; // ms/í‹±
        if (!isPaused && !isOver && (t - lastTick >= step)) {
          lastTick = t;
          update();
        }
        draw();
        requestAnimationFrame(gameLoop);
      }

      function gameOver() { isOver = true; }

      // ë°©í–¥ ì „í™˜(180ë„ ë°˜ì „ ê¸ˆì§€)
      function setDir(x, y) {
        if ((x + direction.x === 0) && (y + direction.y === 0)) return; // ë°˜ëŒ€ ë°©í–¥ ê¸ˆì§€
        nextDirection = { x, y };
      }

      function togglePause() {
        if (isOver) return;
        isPaused = !isPaused;
        btnPause.textContent = isPaused ? 'â–¶ ì¬ê°œ (P)' : 'â¯ ì¼ì‹œì •ì§€';
      }

      // ====== ì…ë ¥ ì²˜ë¦¬ ======
      function handleKey(e) {
        const k = e.key;
        // í™”ì‚´í‘œ ë“± ê¸°ë³¸ ìŠ¤í¬ë¡¤ ë§‰ê¸°
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Spacebar','p','P','r','R'].includes(k)) {
          e.preventDefault();
        }
        switch (k) {
          case 'ArrowUp':    setDir(0,-1); break;
          case 'ArrowDown':  setDir(0, 1); break;
          case 'ArrowLeft':  setDir(-1,0); break;
          case 'ArrowRight': setDir(1, 0); break;
          case 'p': case 'P': togglePause(); break;
          case 'r': case 'R': init(); break;
        }
      }

      // ë²„íŠ¼ ì´ë²¤íŠ¸
      window.addEventListener('keydown', handleKey);
      btnRestart.addEventListener('click', init);
      btnPause.addEventListener('click', togglePause);

      // roundRect í´ë¦¬í•„(êµ¬í˜• ë¸Œë¼ìš°ì € ëŒ€ë¹„)
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
          if (w < 2*r) r = w/2;
          if (h < 2*r) r = h/2;
          this.beginPath();
          this.moveTo(x+r, y);
          this.arcTo(x+w, y,   x+w, y+h, r);
          this.arcTo(x+w, y+h, x,   y+h, r);
          this.arcTo(x,   y+h, x,   y,   r);
          this.arcTo(x,   y,   x+w, y,   r);
          this.closePath();
          return this;
        }
      }

      // ì‹œì‘!
      init();
      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>
